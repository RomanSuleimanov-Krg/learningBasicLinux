## "grep" #ПоискТекстаВФайле  

Следующая команда на очередь - это grep. Данная команда выполняет поиск текста в файле. Она имеет следующий формат:
`grep [OPTIONS] PATTERNS [FILE]` 
Теперь разберем, что из себя представляют данные аргументы:
-  Обязательный аргумент PATTERNS который принимает шаблон текста, который мы хотим найти в файле
-  На месте FILE может быть передан путь к файлу в котором мы будем производить поиск нужного нам текста
- Необязательный аргумент OPTIONS, который дает нам возможность применить шаблон для поиска текста
Вот самый простой пример использования данной команды:
![[Pasted image 20251204223116.png]]

![[Pasted image 20251204223058.png]]

Мы видим что был задан поиск ключевого слова "interface" файлу qqq и мы получили на выводе 3 строки в которых было найдено совпадение, в свою очередь найденное ключевое слово было выделено контрастным цветом.
Вот пример другого использования:
![[Pasted image 20251204224023.png]]
Указав  "\^i"  как аргумент поиска текста мы дали команду найти строки, в которых слова начинаются с буквы i, и пускай даже по наполнению прошлый и текущий вывод идентичен, но то что мы ищем все же разное.
Настроить поиск текста  можно по разному, так что настоятельно советую лично каждому изучить данную команду в документациях.

## "awk" #РазделитьТаблицуНаВыводе 
Данная команда опять же позволяет задать аргумент которые будет являться текстом, который нужно будет найти в файле. Может показаться, что это идентичная команда прошлой, но в действительности awk имеет иной фронт работ. 
Команда имеет следующий общий вид:
`awk '/pattern/{action} file'`
Сперва задает аргумент pattern - шаблон который является текстом по которому будет производиться поиск в файле. Далее action, аргумент который будет говорить, что именно сделать с найденными строками в файле, и в конце команде передается файл в котором будет искаться соответствие.
Для примера у нас есть следующий список сотрудников данные о которых разделены двоеточием, в котором каждая строка имеет следующий формат - Имя:возраст
![[Pasted image 20251204230221.png]]

Предположим, нам нужно получить все строки, где возраст сотрудника = 23

![[Pasted image 20251204230408.png]]

Команда awk позволяет нам различные возможности ее использования, в частности позволяет работать с файлами табличной структуры как файл для примера. Например для данной команды разделителем по умолчанию является пробел, но в нашем файле таковым разделителем является двоеточие, и это не станет нам проблемой. У нас имеется опция -F, которая позволяет самостоятельно указать символ который будет применяться в качестве разделителя
![[Pasted image 20251204231120.png]]

На данном скриншоте видно как мы указали новый символ разделитель и новую команду в фигурных скобках. Данное действие это встроенная команда awk -print, которая при помощи символов разделителя формирует эдакий список, индексы которого начинаются с нуля и обозначаются как $1, и так далее по такой логике. Если же использовать print $0, то будет выведена вся таблица.

## "sed" #ЗаменаТекста  
Данная команда позволяет производить различные манипуляции с текстом и модификации файлов. Она позволяет искать заданный текст и заменять, вставлять и удалять текст в файлах. Я думаю, что она может быть крайне важной командой для автоматизации и написания сценариев
Команда sed имеет следующий общий вид:
`sed [OPTIONS] 's/old-text/new-text/g' fileName`

Где: 
- s - обозначает, что будет происходить процесс подстановки вместо какого-либо текста
- old-text - Текст, который в теории имеется в файле и его нужно будет заменить
- new-text - Текст который появится на мест old-text
- g - Префикс который говорит, что подобные замены old-text на new-text будут производится в каждой строке файла
- fileName - Это файл либо путь к вашему файлу в котором собственно будут производится манипуляции над текстом

Рассказать о данной команде можно много, однако я думаю каждому стоит узнать основные варианты, которые мы можем использовать в sed вместо "s":
- n: чтобы не отображать данные строки после каждой выполненной команды
- -e команда, которую нам нужно использовать, если вы укажете одну команду;
- f разрешает команду чтения для выполнения из указанного файла;
- i создает резервную копию файла, прежде чем редактировать его;
- s означает, что мы указываем несколько файлов и их нужно рассматривать отдельно.

Вот пример использования данной команды:
![[Pasted image 20251205212617.png]]

![[Pasted image 20251205212711.png]]

В данном примере мы заменили пустую строку которая задается параметром вот таким образом "^$" на фраза "Тут было пусто"
